<?php
global $setting;

class Language1{
    protected static $ru = array(
        'types' => array(
            'h1'       => 'Список типов',
            'fstitle'  => 'Быстрый поиск марок и моделей',
            'fsititle' => 'Быстрый поиск марок и моделей (Alt+Ч)',
        ),
        'marks' => array(
            'h1'      => 'Список марок',
            'offsite' => 'Официальный сайт',
        ),
        'models'     => array(
            'h1'  => 'Список моделей',
            'mod' => 'Модификации',
            'act' => 'Актуальность',
        ),
        'tree' => array(
            'h1'         => 'Дерево узлов',
            'open-close' => 'Раскрыть/Закрыть ветку',
        ),
        'map' => array(
            'h1'        => 'Карта размещения деталей',
            'hide-show' => 'Показать/Спрятать метки',
            'zoomdn'    => 'Уменьшить масштаб',
            'zoomdf'    => 'Масштаб 100%',
            'zoomup'    => 'Увеличить масштаб',
            'noimg'     => 'Нет иллюстрации',
            'N'         => '№',
            'detname'   => 'Наименование детали',
            'detnumber' => 'Номер детали',
            'more'      => 'Подробная информация',
            'imglook'   => 'Показать на рисунке',
        ),
        'search' => array(
            'h1title'  => 'Поиск по каталогу запчастей',
            'legend'   => 'Поиск',
            'h1result' => 'Результаты поиска по каталогу запчастей',
            'search'   => 'Вы искали',
            'result'   => 'Найдено',
            'nsearch'  => 'Новый поиск',
        ),
        'searchModels' => array(
            'h1' => 'Результаты быстрого поиска марок и моделей',
        ),
        'detailInfo' => array(
            'title' => 'Подробная информация',
            'h1'    => 'Подробная информация',
            'name'  => 'Автомобиль',
            'mod'   => 'Модификации',
            'act'   => 'Актуальность каталога',
            'dname' => 'Название детали',
            'dnum'  => 'Номер детали',
            'count' => 'Количество',
            'close' => 'закрыть',
        ),
    );
}

class A2D extends Language1 {
    /// Constant16
    protected $_login      = LOGIN;           /// Логин
    protected $_passwd     = PASSWD;          /// Пароль
    protected $_host       = API_HOST;        /// Сайт с API
    protected $_api        = API_VERSION;     /// Каталог с API
    protected $_script     = "in.php";        /// Файл на сервере, принимающий парамтеры
    protected $_img        = "img";           /// Названия каталога с иллюстрациями на сервере
    protected static $_lng = "ru";            /// Язык по умолчанию
    protected static $_fln;                   /// Объявление переменной для файла, вызывающего метод русификации
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///   Переменные по умолчанию для "хлебных крошек" переопределяются в процессе      /////////////////////////////////
    static public $aBreads     = array();          /// Массив с "хлебными крошками"
    static public $spBreads    = "&raquo;";   /// Разделитель "хлебных крошек"
    static public $breadsLogo  = FALSE;       /// Лого для "хлебных крошек"
    static public $bLogo       = FALSE;       /// Признак отображать или нет
    static public $breadsClass = "text-left"; /// Custom CSS для "хлебных крошек"
    static public $catalogRoot = FALSE;       /// Корневой каталог
    static public $mark        = FALSE;       /// Определяется в каждом API интерфейсе. Нужно не только в "хлебных крошках"
    static public $markRoute   = FALSE;       /// Дополнительный параметр (пример BMW)
    static public $markName    = FALSE;       /// Имя марки
    static public $showMark    = TRUE;        /// Показывать марку/нет
    static public $arrActions  = array();          /// Массив с доступными скриптами. В "хлебных крошках" на каждый скрипт свой набор переменных
    static public $humanURL    = FALSE;       /// ЧПУ. По умолчанию (в данных примерах) ЧПУ не используется
    static public $callback    = FALSE;       /// Ссылка на проценку
    static public $offline     = FALSE;       /// (в планах) для дуступа к своему сайту из ваших программ
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Функция установки объекта
    protected static $_instance;
    public static function instance(){
        if( !isset(static::$_instance) ) static::$_instance = new static();
        return static::$_instance;
    }
    /// Установка значений по умолчанию
    public function __construct() {
        session_start();
        date_default_timezone_set(TIMEZONE);
        $this->sUrl   = $this->_host.DS.$this->_api.DS.$this->_script;
        $this->_auth  = $this->getAuth();            /// Собираем пользовательские данные в одну переменную
        $this->uIP    = $_SERVER['REMOTE_ADDR'];     /// Передаем если нужно, чтобы работало ограничение на просмотры с одного клиента
        $this->uAgent = $_SERVER['HTTP_USER_AGENT']; /// Передаем если нужно, чтобы работало ограничение на просмотры с одного клиента
        static::$_fln = basename($_SERVER['PHP_SELF'],".php");
    }
    /// Пример, как можно организовать мультиязычность
    /// Ввели $file, так как иногда необходимо использовать код одного файла в другом (к пр начать каталог с определенной модели)
    public static function lang($param,$file=FALSE){
        $lng = static::$_lng; /// Используемый язык
        $fln = ($file)?$file:static::$_fln; /// В каком файле вызвали функцию
        return static::${$lng}[$fln][$param];
    }
    /// Отправляем запрос на сервер
    public function getAnswer($body,$url=FALSE){
        $url = ($url)?$url:$this->sUrl;
        $ch = curl_init($url);      
        curl_setopt($ch, CURLOPT_HEADER,0);
        curl_setopt($ch, CURLOPT_USERAGENT,$_SERVER['HTTP_USER_AGENT']);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); 
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT,80);
        curl_setopt($ch, CURLOPT_POST,1);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $body);      
        $result=curl_exec($ch); 
        return $result; 
    } 
    /// Получаем переменную из POST. Если пусто, то пытаемся найти ее в GET, иначе отдаем значение по умолчанию
    public function rcv($name,$def=""){
        $dt=htmlentities(@$_POST[$name],ENT_QUOTES,"UTF-8");
        if(!$dt)$dt=htmlentities(@$_GET[$name],ENT_QUOTES,"UTF-8");
        return ($dt)?$dt:$def;
    }
    /// Получить свойство массива
    public static function get($array, $key, $default = NULL){
        return isset($array[$key]) ? $array[$key] : $default;
    }
    /// Получить свойство объекта
    public static function property($obj, $name, $default = NULL){
        return ( isset($obj->{$name}) && !empty($obj->{$name}) ) ? $obj->{$name} : $default;
    }
    /// Вырезать из массива свойсво и вернуть в переменную
    public static function cut(&$array, $key, $default = NULL){
        if( isset($array[$key]) ){ $r = $array[$key]; unset($array[$key]); }else{ $r = $default; }
        return $r;
    }
    /// Преобразовать массив в объект
    public static function toObj($arr){
        return json_decode( json_encode($arr,JSON_FORCE_OBJECT) );
    }
    /// Сперва превращает строку в массив по буквенно, потом через ";" превращает в строку (используется в ETKA в таблице с моделями)
    public static function split($str,$del){
        return implode($del,preg_split('//',$str,-1,PREG_SPLIT_NO_EMPTY));
    }
    /// Вывести содержимое переменнй на экран
    public function p($arg='EMPTY',$title=NULL){
        header('Content-Type: text/html; charset=utf-8');
        if(is_array($arg)) $br='=='; else $br='';
        if($title==NULL) echo $br;
        elseif($title==1) echo 'Contents: '.$br;
        else echo $title.': '.$br;
        print'<pre>';print_r($arg);print'</pre>';
    }
    /// Вывести содержимое переменнй на экран и прекратить выполнение сценария
    public function e($arg='EMPTY',$title=NULL){ $this->p($arg,$title);exit; }
    /// Простая реализация 404 ошибки
    public function error($txt, $errorCode = null){
        if(!is_null($errorCode)){
            $errorCode = (int) $errorCode;
            if ($errorCode == 404) header('HTTP/1.1 404 Not Found');
            else header('HTTP/1.1 '.$errorCode);
        }
        $o1="<HTML><HEAD><META http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"><TITLE>УПС! Ошибка!</TITLE><META name=\"robots\" content=\"noindex,follow\"></HEAD><BODY><H1>УПС! Ошибка!</H1><BLOCKQUOTE style='font-size: 14pt'><B style='color: Red'>";
        $o2="</B></BLOCKQUOTE><I>".date("H:i:s d-m-Y")."</I></BODY></HTML>";
        echo $o1; print'<pre>'; print_r($txt); print'</pre>'; echo $o2; exit;
    }
    /// Функция проверят был ли это AJAX запрос
    static public function ajaxRequest(){
        if( !isset( $_SERVER[ "HTTP_X_REQUESTED_WITH" ] ) || $_SERVER[ "HTTP_X_REQUESTED_WITH" ] != "XMLHttpRequest" ) return FALSE;
        return TRUE;
    }
    /// Преобразовать данные переменной или массива из UTF8 в CP1251
    static function GetTextCP1251($text){
        if(is_array($text) || is_object($text)){
            foreach ($text as &$value){ $value = self::GetTextCP1251($value); }
            return $text;
        }
        if(mb_check_encoding($text, "UTF-8")){
            $text = mb_convert_encoding($text, "WINDOWS-1251", "UTF-8");
        }
        return $text;
    }
    /// Преобразовать данные переменной или массива из CP1251 в UTF8
    static function GetTextUTF8($text){
        if(is_array($text) || is_object($text)){
            foreach ($text as &$value){ $value = self::GetTextUTF8($value); }
            return $text;
        }
        if(mb_check_encoding($text, "WINDOWS-1251")){
            $text = mb_convert_encoding($text, "UTF-8", "WINDOWS-1251");
        }
        return $text;
    }
    /// Создание переменноей с авторизационными данными
    public function getAuth(){
        //$info = "&u=".$this->_login."&p=".$this->_passwd."&h=".$_SERVER['HTTP_HOST'];
		$info = $this->_login;
        return $info;
    }
    /// Получаем полный адрес с интерфейсом API
    public function getHost(){ return $this->_host.DS.$this->_api; }
    /// Получаем полный адрес до изображения на сервере
    public function getImgPath(){ return $this->_host.DS.$this->_img; }

    /// Поучаем путь для марок. Если марка с оригинального каталога, переключаемся каталог, указанный в переменной у марки
    static function getMarkUrl($oMark){
        if( $oMark->external ){ /// Признак, что нужно переключиться в оригинальный каталог
            $arr = explode('/',$oMark->route);
            $mark = end( $arr );
            $action = "main";
            $iface = NULL;
            $var  = 'mark';   /// Передаваемая переменная
            if( in_array($mark,array('bmw','mini','moto','rr')) ){
                $iface  = 'bmw';    /// Директория со скриптами
                $action = 'series'; /// Входная точка
            }
            if( in_array($mark,array('nissan','infiniti')) ){
                $iface  = 'nissan';     /// Директория со скриптами
                $action = 'markets';    /// Входная точка
                $var    = 'mark';       /// Передаваемая переменная
            }
            if( in_array($mark,array('nissan','infiniti')) ){
                $iface  = 'nissan';  /// Директория со скриптами
                $action = 'markets'; /// Входная точка
                $var = 'mark';
            }
            if( in_array($mark,array('toyota','lexus')) ){
                $iface  = 'toyota';  /// Директория со скриптами
                $action = 'markets'; /// Входная точка
            }
            if( in_array($mark,array('audi','volkswagen','seat','skoda')) ){
                $iface  = 'etka';    /// Директория со скриптами
                $action = 'markets'; /// Входная точка
            }
            if( in_array($mark,array('pc','cv')) ){
                $iface  = 'td'; /// Директория со скриптами
                $action = 'marks';       /// Входная точка
                $var    = 'type';        /// Передаваемая переменная
            }
                        $mcct=array();
                        if(preg_match('/^(kia|hyundai)(_(c|s))?$/si',$mark,$mcct))
                        {
                                $mark       = $mcct[1];
                                $iface  = 'mcct';
                                $action = 'index';
                                $var    = 'type='.(!empty($mcct[2])?$mcct[3]:'').'&mark';
                        }

            if( in_array($mark,array('fiat', 'lancia', 'abarth', 'alfa-romeo')) ){
                $iface = 'fiat';
                $action = 'models';
                $var = 'brand';
            }

            $url = "$iface/{$action}.php?{$var}={$mark}";
        }
        else /// Для каталогов от АвтоДилер продолжаем схему, но уже из директории adc
            $url = "adc/models.php?typeID={$oMark->type_id}&markID={$oMark->mark_id}&flag={$oMark->flags}";
        return $url;
    }
    /// "Хлебные крошки"
    static function getBreadsName($mark,$k,$b){
        $mark = strtolower($mark);
        switch( $mark ){
            case "bmw":
                $name = ( $k=="models" ) ?BMW::instance()->_getSeries($b->name) :$b->name;
                break;
            case "toyota":
            case "nissan":
            case "lexus":
                $name = ( $k=="getToyModels" ) ?ucfirst($mark) :$b->name;
                break;
            default:
                $name = static::property($b,'name');
        }
        return $name;
    }
    /// Если нужно пропустить некоторые шаги в "хлебных крошкам", то в данной функции можно это реализовать
    static function getBreads($obj,$name,$iface){
        $aBreads = static::property($obj,$name,array());
        switch( strtolower($iface) ){
            case "etka":
                unset($aBreads->mark);///unset($aBreads->market);unset($aBreads->production);
                break;
            case "bmw":
                ///unset($aBreads->options);unset($aBreads->production);
                break;
            case "td":
                unset($aBreads->types);///unset($aBreads->production);
                break;
        }
        return $aBreads;
    }
    /// Для марки устанавливаем нужные нам параметры, описание выше
    static public function setMark($mark){
        if( !$mark ) return FALSE;
        switch( $mark ){
            case "bmw":
                static::$mark = "bmw";
                static::$markName = "BMW";
                static::$markRoute = "";
                static::$breadsLogo  = "/media/images/bmw/logo/bmw.png";
                break;
            case "mini":
                static::$mark = "mini";
                static::$markName = "Mini";
                static::$markRoute = "/mini";
                static::$breadsLogo  = "/media/images/bmw/logo/mini_small.png";
                break;
            case "moto":
                static::$mark = "moto";
                static::$markName = "Moto";
                static::$markRoute = "/moto";
                static::$breadsLogo  = "/media/images/bmw/logo/bmw.png";
                break;
            case "rr":
                static::$mark = "rr";
                static::$markName = "Rolls-Royce";
                static::$markRoute = "/rr";
                static::$breadsLogo  = "/media/images/bmw/logo/rolls_royce_small.png";
                break;
            default:
                static::$mark = $mark;
                static::$markName = ucfirst($mark);
        }
        /// Пока, к примеру для BMW, не поймано для какой модели будут возвращаться детали
        /// Поэтому пока тупо ход конем
        $_SESSION['mark'] = $mark;
    }
    /// Не используется, скопирована для идеи
    static function callBackLink($detail,$callback=NULL,$name="",$onlyLink=FALSE){
        $name = ( !$name ) ?$detail :$name;
        if( $callback ){
            $_callBack = str_replace('{{DetailNumber}}',$detail,$callback);
            $r = "<a target=\"_blank\" href=\"$_callBack\" onclick=\"window.open(this.href, '_blank'); return false;\"><span class=\"c2c detailNumber\">$name</span></a>";
        }elseif( !$onlyLink ){
            $r = "<span class='c2c detailNumber'>$detail</span>";
        }
        else $r = FALSE;
        return $r;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///   Search Form Section   ////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static $searchMethod = "GET"; /// Каким способом передавать переменные (на POST не унифицировано)
    static $searchIFace  = "";    /// Определяется в API файла каталога
    static $searchTabs   = array();    /// Определяется в API файла каталога
    static $searchWhere  = array();    /// Определяется, где подключаем форму выбора (не адаптировано для внешних каталогов)
    /// Не используется! Скопировано с рабочего сайта для идеи на будущее. Пока все НУЖНОЕ отрабатывает в helpers/search.php
    public function searchForm( $method="POST", $root="", $arr=array(), $from=TRUE ){
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///   For Tabs   ///////////////////////////////////////////////////////////////////////////////////////////////

        $a = $tName = FALSE; /// Нет ни одной активной вкладки
        foreach( $arr AS $t ){
            $tab = "from".ucfirst($t['alias']);
            if( static::get($_GET,$tab) ){
                $a = TRUE; /// Выстрелило
                ${"tab".$t['id']}    ='tab_active';
                ${"tabDiv".$t['id']} ='tabkont_active';
                $tName = $t['tName'];
            }
            else{
                ${"tab".$t['id']}    ='tab';
                ${"tabDiv".$t['id']} ='tabkont';
            }
        }
        if( !$a ){ /// Если нет активных вкладок, то включаем первую
            $tab1    ='tab_active';
            $tabDiv1 ='tabkont_active';
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ///   Хлебные крошки && CheckBoxes   ///////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        $referrer    = $this->request->referrer(); ///$this->e($referrer);
        $whereSearch = static::get($_SESSION,'searchWhere'); ///$this->e(Arr::get($whereSearch,'name'));
        $_active     = ( $this->rcv(static::get($whereSearch,'name')) )?TRUE:FALSE;
        $_ref  = static::get($_SESSION,'searchReferrer'); ///$this->e($_ref);
        $_name = static::get($_ref,'name',"Последняя страница");
        $_url  = static::get($_ref,'value',$referrer);
        $aBreads = array(
            "name" => 'Каталог',
            "breads" => array(
                0 => 'catalog'
            )
        );
        if( $_active && $_ref ){
            $aBreads = array(
                "name" => $_name,
                "breads" => explode('/',ltrim($_url,'/'))
            );
        }
        $aBreads = array(
            "name" => $tName,
            "breads" => array()
        ); ///$this->e($aBreads);
        static::$aBreads = static::toObj($aBreads);
        /// Так боремся с сохранностью всех опций после переходя в контроллер поиска
        if( $_active && $whereSearch ){ ///$this->e($whereSearch);
            static::$whereSearch  = array(
                'tabs'  => static::get($whereSearch,'tabs'),
                'name'  => static::get($whereSearch,'name'),
                'value' => static::get($whereSearch,'value'),
                'desc'  => static::get($whereSearch,'desc'),
            );
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }


}



class ObjectAndXML {
    private $xml;

    // Constructor
    public function __construct() {
        $this->xml = new XmlWriter();
        $this->xml->openMemory();
        $this->xml->startDocument('1.0');
        $this->xml->setIndent(true);
    }

    // Method to convert Object into XML string
    public function objToXML($obj) {
        $obj = array('root'=>$obj);
        $this->getObject2XML($this->xml, $obj);

        $this->xml->endElement();

        return $this->xml->outputMemory(true);
    }

    // Method to convert XML string into Object
    public function xmlToObj($xmlString) {
        return simplexml_load_string($xmlString);
    }

    private function getObject2XML(XMLWriter $xml, $data) {
        foreach($data as $key => $value) {
            if(is_object($value)) {
                if( (int)$key{0}>0 ) $key = "ID_".$key;
                $xml->startElement($key);
                $this->getObject2XML($xml, $value);
                $xml->endElement();
                continue;
            }
            else if(is_array($value)) {
                $this->getArray2XML($xml, $key, $value);
            }

            if (is_string($value)) {
                $xml->writeElement($key, $value);
            }
        }
    }

    private function getArray2XML(XMLWriter $xml, $keyParent, $data) {
        foreach($data as $key => $value) {
            if (is_string($value)) {
                $xml->writeElement($keyParent, $value);
                continue;
            }

            if (is_numeric($key)) {
                $xml->startElement($keyParent);
            }

            if(is_object($value)) {
                $this->getObject2XML($xml, $value);
            }
            else if(is_array($value)) {
                $this->getArray2XML($xml, $key, $value);
                continue;
            }

            if (is_numeric($key)) {
                $xml->endElement();
            }
        }
    }
}

class ADC extends A2D {

    /// Тип каталога, для АвтоДилер пока не указывается
    protected static $_type = "ADC";
    /// Производим базовые настройки
    public function __construct(){
        parent::__construct();
        static::$catalogRoot = "";
        static::setMark($this->rcv('mark'));
        /// Для "хлебных крошек", на какой каталог ссылаться при построении крошек
        /// Данным значениям (static::$arrActions) в helpers/breads.php сопоставляются последовательно параметрам из A2D::$aBreads
        static::$arrActions = array('typeID','markID','modelID','treeID');
        /// Корневой каталог, откуда стартовать скрипты поиска для текущего каталога (используется в конструкторе формы поиска)
        static::$searchIFace = "adc";
        /// Массив для построение формы с поиском (опиание в главном README.MD)
        static::$searchTabs = array(array(
            'id'    => 1,
            'alias' => 'detail',
            'name'  => 'номер детали', /// В контексте "Укажите ..."
            'tName' => 'Поиск по номеру детали'
        ),array(
            'id'    => 2,
            'alias' => 'model',
            'name'  => 'Модель', /// В контексте "Укажите ..."
            'tName' => 'Поиск модели'
        ));
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///   СТАНДАРТНЫЕ ФУНКЦИИ ДЛЯ ПОЛУЧЕНИЯ ДАННЫХ   ///////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// Пулочение списка групп/типов автомобилей
    public function getTypeList(){
        $body = "f=".__FUNCTION__.$this->_auth;
        $answer = $this->getAnswer($body);
        $r = json_decode($answer, 1);
        return $r;
    }
    /// Получаем марки по типу или все
    public function getMarkList($type=FALSE){
        $body = "f=".__FUNCTION__.$this->_auth."&typeID=$type";
        $answer = $this->getAnswer($body);
        $r = json_decode($answer);
        return $r;
    }
    /// Получение списка моделей по типу и марке или только марке
    public function getModelList($mark,$type=FALSE){
        $body = "f=".__FUNCTION__.$this->_auth."&typeID=$type&markID=$mark";
        $answer = $this->getAnswer($body);
        $r = json_decode($answer);
        return $r;
    }
    /// Получение всех деталей и их узлов для текущей модели
    public function getTreeList($model,$bMultiArray){
        $body = "f=".__FUNCTION__.$this->_auth."&modelID=$model&multiArray=$bMultiArray";
        $answer = $this->getAnswer($body);
        $r = json_decode($answer);
        return $r;
    }
    /// Иллюстрация и список номенклатуры для выбранной детали
    public function getDetails($model,$detail,$jump){
        $body = "f=".__FUNCTION__.$this->_auth."&modelID=$model&treeID=$detail&jumpPic=$jump";
        $answer = $this->getAnswer($body);
        $r = json_decode($answer);
        return $r;
    }
    /// Получении информации о детали
    public function getDetailInfo($model,$detail){
        $body = "f=".__FUNCTION__.$this->_auth."&modelID=$model&treeID=$detail";
        $answer = $this->getAnswer($body);
        $r = json_decode($answer);
        return $r;
    }
    /// Поиск модели
    public function searchModels($model){
        $body = "f=".__FUNCTION__.$this->_auth."&model=$model";
        $answer = $this->getAnswer($body);
        $r = json_decode($answer);
        return $r;
    }
    public function searchNumber($sSearch=FALSE,$whereName=FALSE,$whereValue=FALSE,$detailed=FALSE){
        $body = "f=".__FUNCTION__.$this->_auth."&search=$sSearch&$whereName=$whereValue&detailed=$detailed";
        $answer = $this->getAnswer($body);
        $r = json_decode($answer);
        return $r;
    }

}


# 
function findTovarSql($find) {

$zamArr = array("\\\'" => "","\'" => "","'" => "","\\" => " ","\"" => "", "/" => " ", "-" => " ", "," => " ",", " => " ","." => " "," и " => " "," на " => " ","=" => " ");
	$find = strtr($find, $zamArr);
    $find = htmlspecialchars(strip_tags(addslashes($find)));
	//if ($AUTH_USER_ID==2) echo $find;
    $find = str_replace("  "," ",$find);

  $findVars = explode(" или ",$find);
 
  foreach($findVars as $fvar) {
     $fvar = strtr($fvar, $zamArr);
     $fvar = str_replace("  "," ",$fvar);
     $findArr = explode(" ",$fvar);
     $stringsearch = '';
      foreach($findArr as $word) { unset($wordF);
        if ($word) {
          $word = trim($word);
          $wordF = $word;
          if (!is_numeric($word) && mb_strlen($word)>5 && mb_strlen($word)<8 && preg_match('/[а-яА-Я]+/', $word)) $word = mb_substr($word,0,-1);
          if (!is_numeric($word) && mb_strlen($word)>=8 && mb_strlen($word)<12 && preg_match('/[а-яА-Я]+/', $word)) $word = mb_substr($word,0,-2);
          if (!is_numeric($word) && mb_strlen($word)>=12 && preg_match('/[а-яА-Я]+/', $word)) $word = mb_substr($word,0,-3);
          $stringsearch .= ($stringsearch ? " AND " : NULL)."(
                        a.name like '%$word%' OR 
                        a.art like '%$wordF%' OR 
                        ".(!in_array($catalogue,$noSearchInText) ? "a.text like '%$word%' OR a.descr like '%$word%' OR " : NULL)."
                        a.vendor like '%$word%' OR 
                        a.code like '%$wordF%' OR 
						a.artnull like '%$wordF%' OR 
						a.analog like '%$wordF%' OR 
                        a.tags like '% $wordF %' OR a.tags like '$wordF' OR a.tags like '$wordF,%' OR a.tags like '$wordF %' OR a.tags like '% $wordF,%' OR a.tags like '%,$wordF,%' OR a.tags like '% $wordF' OR a.tags like '%,$wordF' OR 
						".(!in_array($catalogue,$noSearchInText) ? "a.var1 like '% $wordF %' OR a.var1 like '$wordF' OR a.var1 like '$wordF,%' OR a.var1 like '$wordF %' OR a.var1 like '% $wordF,%' OR a.var1 like '%,$wordF,%' OR a.var1 like '% $wordF' OR a.var1 like '%,$wordF' OR " : NULL)."
						a.var2 like '%$wordF%' OR 
						a.var3 like '%$wordF%' OR 
						a.var4 like '%$wordF%' OR 
						a.var5 like '%$wordF%' OR 
						a.var6 like '%$wordF%' OR 
						a.var7 like '%$wordF%' OR 
						a.var8 like '%$wordF%' OR 
						a.var9 like '%$wordF%' OR 
						a.var10 like '%$wordF%' OR 
						a.var11 like '%$wordF%' OR 
						a.var12 like '%$wordF%' OR 
						a.var13 like '%$wordF%' OR 
						a.var14 like '%$wordF%' OR 
						a.var15 like '%$wordF%' 
                        )";
        }
      }

      $stringsearchAll .= ($stringsearchAll ? " OR " : NULL).$stringsearch;
	}
    return $stringsearchAll;
}